import numpy as npimport osimport pandas as pdimport open_ephys_IOimport PostSorting.parametersimport itertoolsimport mathimport matplotlib.pylab as pltimport PostSorting.vr_stop_analysisprm = PostSorting.parameters.Parameters()# for testing: load behavioural datadef load_spatial_data(position_data,recording_folder):    print('Loading spatial data...')    location_in_cm = np.load(recording_folder + "/Data_test/location.npy")    position_data['x_position_cm'] = location_in_cm # fill in dataframe    trials = np.load(recording_folder + "/Data_test/trials.npy")    position_data['trial_number'] = trials # fill in dataframe    trials = np.load(recording_folder + "/Data_test/trial_type.npy")    position_data['trial_type'] = trials # fill in dataframe    return position_data# correct for if blender was restarted during the recordingdef correct_for_restart(location):    location[location <0.55] = 0.56 # deals with if the VR is switched off during recording - location value drops to 0 - min is usually 0.56 approx    return location# plot the raw movement channel to check all is gooddef plot_movement_channel(location):    plt.plot(location)    plt.savefig(prm.get_local_recording_folder_path() + '/Figures/movement' + '.png')    plt.close()# load location pindef get_raw_location(recording_folder):    print('Extracting raw location...')    file_path = recording_folder + '/' + prm.get_movement_channel()    if os.path.exists(file_path):        location = open_ephys_IO.get_data_continuous(prm, file_path)    else:        print('Movement data was not found.')    location=correct_for_restart(location)    plot_movement_channel(location)    return np.asarray(location, dtype=np.float16)# convert DAQ input to cmdef calculate_track_location(position_data, recording_folder):    recorded_location = get_raw_location(recording_folder) # get raw location from DAQ pin    plot_movement_channel(recorded_location)    print('Converting raw location input to cm...')    recorded_startpoint = min(recorded_location)    recorded_endpoint = max(recorded_location)    recorded_track_length = recorded_endpoint - recorded_startpoint    distance_unit = recorded_track_length/prm.get_track_length()  # Obtain distance unit (cm) by dividing recorded track length to actual track length    location_in_cm = (recorded_location - recorded_startpoint) / distance_unit    position_data['x_position_cm'] = location_in_cm # fill in dataframe    np.save(recording_folder + "/Data_test/location", location_in_cm)#for testing    return position_data# calculate time from start of recording in seconds for each sampling pointdef calculate_time(position_data):    print('Calculating time...')    position_data['time_ms'] = position_data['x_position_cm'].index/30000 # convert sampling rate to time (seconds) by dividing by 30    position_data['time_ms'] = position_data['time_ms']+0.001    return position_data# for each sampling point, calculates time from last sample pointdef calculate_instant_dwell_time(position_data):    print('Calculating dwell time...')    position_data['dwell_time_ms'] = position_data['time_ms'].diff() # [row] - [row-1]    return position_data# finds time animal spent in each location bin for each trialdef calculate_binned_dwell_time(position_data):    print('Calculating binned dwell time...')    dwell_rate_map = pd.DataFrame(columns=['trial_number','bin_count', 'dwell_time_ms'])    bin_size_cm,number_of_bins = PostSorting.vr_stop_analysis.get_bin_size(position_data)    number_of_trials = position_data.trial_number.max() # total number of trials    trials = np.array(position_data['trial_number'].tolist())    locations = np.array(position_data['x_position_cm'].tolist())    dwell_time_per_sample = np.array(position_data['dwell_time_ms'].tolist())  # Get the raw location from the movement channel    for t in range(1,int(number_of_trials)):        trial_locations = np.take(locations, np.where(trials == t)[0])        for loc in range(int(number_of_bins)):            time_in_bin = sum(dwell_time_per_sample[np.where(np.logical_and(trial_locations > loc, trial_locations <= (loc+1)))])            dwell_rate_map = dwell_rate_map.append({"trial_number": int(t), "bin_count": int(loc),  "dwell_time_ms":  (time_in_bin)}, ignore_index=True)    position_data['binned_time_ms'] = dwell_rate_map['dwell_time_ms']    return position_data# calculates trial number from continuous channeldef calculate_trial_numbers(position_data):    print('Calculating trial numbers...')    location_diff = position_data['x_position_cm'].diff()  # Get the raw location from the movement channel    trials = np.zeros((len(location_diff)))    new_trial_indices = np.where(location_diff < -150) # return indices where is new trial    new_trial_indices = list(itertools.chain.from_iterable(new_trial_indices)) # needed to convert tuple to list    unique_trials = np.arange(1, len(new_trial_indices), 1)    for icount,i in enumerate(unique_trials):        trial_start_indices = new_trial_indices[icount]        next_trial_indices = new_trial_indices[icount+1]        trials[trial_start_indices:next_trial_indices] = i    position_data['trial_number'] = np.asarray(trials, dtype=np.uint8)    print('This mouse did ', int(max(trials)), ' trials')    np.save(prm.get_file_path() + "/Data_test/trials", np.asarray(trials, dtype=np.uint8))#for testing    return position_data# two continuous channels represent trial typedef load_trial_types_from_continuous(recording_folder):    first = []    file_path = recording_folder + '/' + prm.get_first_trial_channel() #todo this should bw in params, it is 100 for me, 105 for Tizzy (I don't have _0)    trial_first = open_ephys_IO.get_data_continuous(prm, file_path)    first.append(trial_first)    first=np.asarray(first)    second = []    file_path = recording_folder + '/' + prm.get_second_trial_channel() #todo this should bw in params, it is 100 for me, 105 for Tizzy (I don't have _0)    trial_second = open_ephys_IO.get_data_continuous(prm, file_path)    second.append(trial_second)    second = np.asarray(second)    return first,seconddef calculate_trial_types(position_data, recording_folder):    print('Calculating trial types from continuous...')    first, second = load_trial_types_from_continuous(recording_folder)    trial_type = np.zeros((first.shape[1]));trial_type[:]=np.nan    for point,p in enumerate(trial_type):        if second[0,point] < 2 and first[0,point] < 2: # if beaconed            trial_type[point] = int(0)        if second[0,point] > 2 and first[0,point] < 2: # if beaconed            trial_type[point] = int(1)        if second[0,point] > 2 and first[0,point] > 2: # if non beaconed            trial_type[point] = int(2)    position_data['trial_type'] = np.asarray(trial_type, dtype=np.uint8)    np.save(prm.get_file_path() + "/Data_test/trial_type", np.asarray(trial_type, dtype=np.uint8))#for testing    return position_datadef fix_teleport(velocity):    max_velocity = max(velocity)    track_length = 200    # If the mouse goes from the end of the track to the beginning, the velocity would be a negative value    # if velocity< (-1)*track_length + max_velocity, then track_length is added to the value    too_small_indices = np.where(velocity < (-track_length + max_velocity))    too_small_values = np.take(velocity, too_small_indices)    to_insert = too_small_values + track_length    np.put(velocity, too_small_indices, to_insert)  # replace small values with new correct value    # if velocity is <-10 (due to the teleportation), the previous velocity value will be used    small_velocity = np.where(velocity < -10)  # find where speed is < 10    small_velocity = np.asanyarray(small_velocity)    previous_velocity_index = small_velocity - 1  # find indices right before those in previous line    previous_velocity = np.take(velocity, previous_velocity_index)    np.put(velocity, small_velocity, previous_velocity)  # replace small speed values with previous value    return velocitydef calculate_instant_velocity(position_data):    print('Calculating velocity...')    location = np.array(position_data['x_position_cm']) # Get the raw location from the movement channel    sampling_points_per200ms = int(prm.get_sampling_rate()/5)    end_of_loc_to_subtr = location[:-sampling_points_per200ms]# Rearrange arrays in a way that they just need to be subtracted from each other    beginning_of_loc_to_subtr = location[:sampling_points_per200ms]# Rearrange arrays in a way that they just need to be subtracted from each other    location_to_subtract_from = np.append(beginning_of_loc_to_subtr, end_of_loc_to_subtr)    velocity = location - location_to_subtract_from    velocity = fix_teleport(velocity)    position_data['velocity'] = velocity    np.save(prm.get_file_path() + "/Data_test/", velocity) #for testing    return position_datadef moving_sum(array, window):    ret = np.cumsum(array, dtype=float)    ret[window:] = ret[window:] - ret[:-window]    return ret[window:]def get_rolling_sum(array_in, window):    if window > (len(array_in) / 3) - 1:        print('Window is too big, plot cannot be made.')    inner_part_result = moving_sum(array_in, window)    edges = np.append(array_in[-2 * window:], array_in[: 2 * window])    edges_result = moving_sum(edges, window)    end = edges_result[window:math.floor(len(edges_result)/2)]    beginning = edges_result[math.floor(len(edges_result)/2):-window]    array_out = np.hstack((beginning, inner_part_result, end))    return array_outdef get_avg_speed_200ms(position_data):    print('Calculating average speed...')    velocity = np.array(position_data['velocity'])  # Get the raw location from the movement channel    sampling_points_per200ms = int(prm.get_sampling_rate()/5)    position_data['speed_per200ms'] = get_rolling_sum(velocity, sampling_points_per200ms)# Calculate average speed at each point by averaging instant velocities    return position_datadef calculate_binned_speed(position_data):    bin_size_cm,number_of_bins = PostSorting.vr_stop_analysis.get_bin_size(position_data)    number_of_trials = position_data.trial_number.max() # total number of trials    speed = []    speed_ms = np.array(position_data['speed_per200ms'].tolist())    locations = np.array(position_data['x_position_cm'].tolist())    for loc in range(int(number_of_bins)):        speed_in_bin = np.mean(speed_ms[np.where(np.logical_and(locations > loc, locations <= (loc+1)))])/number_of_trials        speed = np.append(speed,speed_in_bin)    position_data.binned_speed_ms.iloc[range(int(number_of_bins))] = speed    return position_datadef process_position_data(recording_folder, prm):    # make data frame    position_data = pd.DataFrame(columns=['time_ms', 'dwell_time_ms', 'x_position_cm', 'velocity', 'speed_per200ms', 'binned_speed_ms', 'trial_number', 'trial_type', 'stop_location_cm', 'stop_trial_number', 'stop_trial_type', 'rewarded_locations', 'rewarded_trials', 'average_stops', 'sd_stops', 'position_bins', 'binned_time_ms'])    if os.path.isfile(recording_folder + "/Data_test/location.npy") is False: # for testing        position_data = calculate_track_location(position_data, recording_folder)        position_data = calculate_trial_numbers(position_data)        position_data = calculate_trial_types(position_data, recording_folder)    else:        position_data = load_spatial_data(position_data, recording_folder) # load spatial data    position_data = calculate_time(position_data)    position_data = calculate_instant_dwell_time(position_data)    position_data = calculate_binned_dwell_time(position_data)    position_data = calculate_instant_velocity(position_data)    position_data = get_avg_speed_200ms(position_data)    position_data = calculate_binned_speed(position_data)    position_data = PostSorting.vr_stop_analysis.process_stops(position_data)    prm.set_total_length_sampling_points(position_data.time_ms.values[-1])  # seconds    return position_data#  for testingdef main():    print('-------------------------------------------------------------')    params = PostSorting.parameters.Parameters()    recording_folder = 'C:/Users/s1466507/Documents/Ephys/test_overall_analysis/M5_2018-03-06_15-34-44_of'    vr_spatial_data = process_position_data(recording_folder)if __name__ == '__main__':    main()